(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const a of i.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function t(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function n(s){if(s.ep)return;s.ep=!0;const i=t(s);fetch(s.href,i)}})();const y="ws://localhost:8808",S=[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"}],g=16*1024*1024,b=16*1024;class C{constructor(e=500,t=3e4){this.min=e,this.max=t,this.attempt=0}delay(){const e=Math.min(this.max,this.min*2**this.attempt);return console.debug("[Backoff] delay =",e),this.attempt++,e}reset(){console.debug("[Backoff] reset"),this.attempt=0}}async function m(h){const e=await crypto.subtle.digest("SHA-256",h);return Array.from(new Uint8Array(e)).map(t=>t.toString(16).padStart(2,"0")).join("")}class p{constructor(){this.backoff=new C,this.socket=null,this.userId=null,this.room=null,this.peerConnections=new Map,this.dataChannels=new Map,this.makingOffer=new Map,this._pendingCandidates=new Map,this.fileQueues=new Map,this.currentSendingFiles=new Map,this.sendingAcks=new Map,this.receivingFiles=new Map,this.setupUI(),this.installTeardownHook(),this.checkAuthKey()}setupUI(){this.roomForm=document.getElementById("room-form"),this.roomInput=document.getElementById("room-input"),this.fileInput=document.getElementById("file-input"),this.fileList=document.getElementById("file-list"),this.peerList=document.getElementById("peer-list"),this.yourIdSpan=document.getElementById("your-id"),this.currentRoomSpan=document.getElementById("current-room"),this.connectionStatusSpan=document.getElementById("connection-status"),this.modal=document.getElementById("custom-modal"),this.modalTitle=document.getElementById("modal-title"),this.modalMessage=document.getElementById("modal-message"),this.modalInput=document.getElementById("modal-input"),this.modalOkBtn=document.getElementById("modal-ok-btn"),this.modalCancelBtn=document.getElementById("modal-cancel-btn"),this.roomForm.addEventListener("submit",async e=>{e.preventDefault();const t=this.roomInput.value.trim();console.debug("[UI] joinRoom ->",t),t&&this.userId?await this.joinRoom(t):this.userId||this.showAlert("Authentication Required","Please enter your key first.")}),this.fileInput.addEventListener("change",e=>{console.debug("[UI] files selected:",e.target.files),this.enqueueFiles(e.target.files)})}showAlert(e,t){return this.modalTitle.textContent=e,this.modalMessage.textContent=t,this.modalInput.style.display="none",this.modalCancelBtn.style.display="none",this.modalOkBtn.textContent="OK",this.modal.style.display="block",new Promise(n=>{this.modalOkBtn.onclick=()=>{this.modal.style.display="none",n()}})}showPrompt(e,t,n=""){return this.modalTitle.textContent=e,this.modalMessage.textContent=t,this.modalInput.value=n,this.modalInput.type="text",this.modalInput.style.display="block",this.modalCancelBtn.style.display="inline-block",this.modalOkBtn.textContent="Submit",this.modal.style.display="block",new Promise(s=>{const i=()=>{this.modal.style.display="none",s(this.modalInput.value),this.modalOkBtn.removeEventListener("click",i),this.modalCancelBtn.removeEventListener("click",a)},a=()=>{this.modal.style.display="none",s(null),this.modalOkBtn.removeEventListener("click",i),this.modalCancelBtn.removeEventListener("click",a)};this.modalOkBtn.addEventListener("click",i),this.modalCancelBtn.addEventListener("click",a)})}async checkAuthKey(){let e=localStorage.getItem("ft_key");if(!e)if(e=await this.showPrompt("Authentication Key","Please enter your unique key for authentication:"),e)console.debug("[Auth] key stored"),localStorage.setItem("ft_key",e);else{await this.showAlert("Auth Cancelled","You must provide a key to use the service.");return}this.userId=e,this.yourIdSpan.textContent=this.userId}installTeardownHook(){window.addEventListener("beforeunload",()=>{console.debug("[Lifecycle] beforeunload, closing"),this.close()})}async joinRoom(e){if(this.room===e&&this.socket&&this.socket.readyState===WebSocket.OPEN){console.info(`[Signal] Already in room ${e}`);return}this.room=e,this.currentRoomSpan.textContent=this.room,console.debug("[Signal] Attempting to join room",e),this.connect()}connect(){if(this.socket&&(this.socket.readyState===WebSocket.CONNECTING||this.socket.readyState===WebSocket.OPEN)){console.debug("[Signal] WebSocket already connecting or open.");return}this.updateConnectionStatus("Connecting...");const e=encodeURIComponent(localStorage.getItem("ft_key")),t=`${y}/?token=${e}`;console.debug("[Signal] connecting to",t),this.socket=new WebSocket(t),this.socket.onopen=()=>{console.debug("[Signal] WS open, resetting backoff"),this.backoff.reset(),this.send({type:"join",room:this.room,userId:this.userId}),this.updateConnectionStatus("Connected")},this.socket.onmessage=n=>{console.debug("[Signal] WS message",n.data),this.onWS(n)},this.socket.onerror=n=>{console.error("[Signal] WS error",n),this.updateConnectionStatus("Error"),this.showAlert("WebSocket Error","Failed to connect to signaling server.")},this.socket.onclose=()=>{console.debug("[Signal] WS closed, retry in backoff"),this.updateConnectionStatus("Disconnected"),this.peerConnections.forEach(n=>n.close()),this.peerConnections.clear(),this.dataChannels.clear(),this.peerList.innerHTML="",setTimeout(()=>this.connect(),this.backoff.delay())}}send(e){this.socket&&this.socket.readyState===WebSocket.OPEN?(console.debug("[Signal] send",e),this.socket.send(JSON.stringify(e))):console.warn("[Signal] WebSocket not open, message not sent:",e)}onWS(e){if(typeof e.data=="string"){let t;try{t=JSON.parse(e.data)}catch{console.warn("[Signal] invalid JSON",e.data);return}this.handleSignaling(t)}}async handleSignaling(e){switch(console.debug("[Signal] handleSignaling",e),e.type){case"welcome":this.userId=e.userId,this.yourIdSpan.textContent=this.userId,this.currentRoomSpan.textContent=e.room,console.info(`[Signal] Welcome, user ${e.userId}, in room ${e.room}`),e.peers.forEach(t=>{t!==this.userId&&(this.setupPeer(t,!0),this.addPeerToUI(t,"connecting"))});return;case"peer_joined":console.info(`[Signal] Peer joined: ${e.peerId}`),e.peerId!==this.userId&&(this.setupPeer(e.peerId,!1),this.addPeerToUI(e.peerId,"connecting"));return;case"peer_left":console.info(`[Signal] Peer left: ${e.peerId}`),this.removePeer(e.peerId);return;case"signal":this.onSignal(e);return;case"error":console.error("[Signal] Server error:",e.code||e.message),this.showAlert(`Server Error: ${e.code||"Unknown"}`,e.message||"An unknown server error occurred.");return;default:console.warn("[Signal] Unknown message type:",e.type)}}setupPeer(e,t=!1){if(this.peerConnections.has(e))return this.peerConnections.get(e);console.debug(`[Peer] setupPeer for ${e}, initiator: ${t}`);const n=new RTCPeerConnection({iceServers:S});if(this.peerConnections.set(e,n),this.makingOffer.set(e,!1),n.onicecandidate=s=>{s.candidate&&(console.debug(`[Peer] ${e} local ICE candidate`,s.candidate),this.send({type:"signal",room:this.room,targetId:e,candidate:s.candidate}))},n.onnegotiationneeded=async()=>{if(!this.makingOffer.get(e)){console.debug(`[Peer] ${e} onnegotiationneeded`),this.makingOffer.set(e,!0);try{const s=await n.createOffer();await n.setLocalDescription(s),console.debug(`[Peer] ${e} sending offer`,s),this.send({type:"signal",room:this.room,targetId:e,description:n.localDescription})}catch(s){console.error(`[Peer] ${e} error creating/sending offer:`,s)}finally{this.makingOffer.set(e,!1)}}},n.oniceconnectionstatechange=()=>{console.debug(`[Peer] ${e} ICE state:`,n.iceConnectionState),this.updatePeerStatusUI(e,n.iceConnectionState),n.iceConnectionState==="failed"?(console.warn(`[Peer] ${e} ICE failed, restarting`),n.restartIce().catch(s=>console.error(`[Peer] ${e} restartIce error:`,s))):(n.iceConnectionState==="disconnected"||n.iceConnectionState==="closed")&&this.removePeer(e)},n.ondatachannel=s=>{console.debug(`[Peer] ${e} incoming DataChannel`,s.channel.label),this.setupDC(e,s.channel)},t){const s=n.createDataChannel("file-transfer");console.debug(`[Peer] ${e} created DataChannel`),this.setupDC(e,s)}return n}async onSignal(e){const t=e.senderId;if(!t){console.warn("[Peer] Received signal without senderId:",e);return}let n=this.peerConnections.get(t);if(n||(n=this.setupPeer(t,!1),this.addPeerToUI(t,"connecting")),e.description){const s=e.description.type==="offer";if(s&&(this.makingOffer.get(t)||n.signalingState!=="stable")?(console.warn(`[Peer] ${t} collision, rolling back`),await Promise.all([n.setLocalDescription({type:"rollback"}).catch(o=>console.error(`[Peer] ${t} rollback error:`,o)),n.setRemoteDescription(e.description).catch(o=>console.error(`[Peer] ${t} setRemoteDescription error:`,o))])):await n.setRemoteDescription(e.description).catch(o=>console.error(`[Peer] ${t} setRemoteDescription error:`,o)),s){console.debug(`[Peer] ${t} creating answer`);const o=await n.createAnswer();await n.setLocalDescription(o),console.debug(`[Peer] ${t} sending answer`,o),this.send({type:"signal",room:this.room,targetId:t,description:n.localDescription})}(this._pendingCandidates.get(t)||[]).forEach(o=>{console.debug(`[Peer] ${t} draining candidate`,o),n.addIceCandidate(o).catch(r=>console.error(`[Peer] ${t} addIceCandidate error:`,r))}),this._pendingCandidates.set(t,[])}else if(e.candidate)if(n.remoteDescription&&n.remoteDescription.type)console.debug(`[Peer] ${t} addIceCandidate`,e.candidate),await n.addIceCandidate(e.candidate).catch(s=>console.error(`[Peer] ${t} addIceCandidate error:`,s));else{console.debug(`[Peer] ${t} queueing candidate`,e.candidate);const s=this._pendingCandidates.get(t)||[];s.push(e.candidate),this._pendingCandidates.set(t,s)}}setupDC(e,t){console.debug(`[DC] setup for ${e}, label: ${t.label}`),this.dataChannels.set(e,t),t.binaryType="arraybuffer",t.bufferedAmountLowThreshold=g,t.onopen=()=>{console.info(`[DC] ${e} open`),this.updatePeerStatusUI(e,"connected"),this.flushQueue(e)},t.onbufferedamountlow=()=>{console.info(`[DC] ${e} bufferedAmountLow`),this.flushQueue(e)},t.onmessage=n=>{console.debug(`[DC] ${e} message`,n.data),this.handleDCMessage(e,n.data)},t.onclose=()=>{console.warn(`[DC] ${e} closed`),this.updatePeerStatusUI(e,"disconnected"),this.removePeer(e)},t.onerror=n=>{console.error(`[DC] ${e} error:`,n),this.showAlert("Data Channel Error",`Error with data channel to ${e}.`)}}async handleDCMessage(e,t){var s,i,a;let n=this.receivingFiles.get(e);if(n||(n={buffer:[],fileName:"",expectedSize:0,expectedHash:"",offset:0,progressBarEl:null,fileItemEl:null},this.receivingFiles.set(e,n)),typeof t=="string"){const o=JSON.parse(t);console.debug(`[DC] ${e} control message`,o),o.type==="meta"?(n.fileName=o.fileName,n.expectedSize=o.fileSize,n.expectedHash=o.hash,n.buffer=[],n.offset=0,console.info(`[File] ${e} meta received: ${o.fileName} (${o.fileSize} bytes)`),n.fileItemEl=this.addReceivedFileToUI(e,o.fileName,o.fileSize),n.progressBarEl=n.fileItemEl.querySelector(".progress-bar")):o.type==="chunk_request"?(this.dataChannels.get(e).send(JSON.stringify({type:"chunk_ack",offset:o.offset})),console.debug(`[File] ${e} sending ack for chunk_request at offset ${o.offset}`)):o.type==="chunk_ack"&&((i=(s=this.sendingAcks.get(e))==null?void 0:s.get(o.offset))==null||i(),(a=this.sendingAcks.get(e))==null||a.delete(o.offset),console.debug(`[File] ${e} ack received for offset ${o.offset}`))}else{if(n.buffer.push(t),n.offset+=t.byteLength,console.debug(`[File] ${e} data chunk received, offset=${n.offset}`),n.progressBarEl){const o=n.offset/n.expectedSize*100;n.progressBarEl.style.width=`${o}%`}n.offset>=n.expectedSize&&this.finishReceive(e)}}enqueueFiles(e){this.fileList.innerHTML="";for(const t of e){const n=document.createElement("li");n.textContent=t.name,n.dataset.fileName=t.name,this.fileList.appendChild(n),this._tempLocalFiles||(this._tempLocalFiles=new Map),this._tempLocalFiles.set(t.name,t)}console.info("[File] local queue updated, count=",e.length)}async sendFileToPeer(e,t){const n=this._tempLocalFiles.get(t);if(!n){this.showAlert("File Not Found",`Selected file "${t}" not found for sending.`);return}if(!this.dataChannels.has(e)||this.dataChannels.get(e).readyState!=="open"){this.showAlert("Peer Not Connected",`Data channel to peer ${e} is not open.`);return}if(this.currentSendingFiles.has(e)){this.showAlert("Transfer In Progress",`A file is already being sent to ${e}. Please wait.`);return}this.fileQueues.has(e)||this.fileQueues.set(e,[]),this.fileQueues.get(e).push(n);const s=this.fileList.querySelector(`li[data-file-name="${t}"]`);s&&s.remove(),this._tempLocalFiles.delete(t),this.showAlert("File Queued",`"${t}" has been queued for sending to ${e}.`),this.flushQueue(e)}async flushQueue(e){const t=this.dataChannels.get(e),n=this.fileQueues.get(e);if(!t||t.readyState!=="open"||this.currentSendingFiles.has(e)||!n||n.length===0)return;const s=n.shift();if(!s)return;console.info(`[File] Sending "${s.name}" to ${e}`);const i=await s.arrayBuffer(),a=await m(i);this.currentSendingFiles.set(e,{file:s,offset:0,totalSize:i.byteLength,hash:a}),this.sendingAcks.set(e,new Map);const o=this.addSentFileToUI(e,s.name,s.size),r=o.querySelector(".progress-bar"),c=o.querySelector(".file-status");t.send(JSON.stringify({type:"meta",fileName:s.name,fileSize:i.byteLength,hash:a}));let l=0;for(;l<i.byteLength;){const u=i.slice(l,Math.min(l+b,i.byteLength));console.debug(`[File] ${e} sending chunk offset=${l}, size=${u.byteLength}`);const f=this.currentSendingFiles.get(e);if(f&&(f.offset=l),t.send(JSON.stringify({type:"chunk_request",offset:l})),t.send(u),r){const d=(l+u.byteLength)/i.byteLength*100;r.style.width=`${d}%`}for(await new Promise(d=>{this.sendingAcks.get(e).set(l,d)}),l+=u.byteLength;t.bufferedAmount>g;)console.debug(`[File] ${e} bufferedAmount high (${t.bufferedAmount}), waiting...`),c.textContent="Buffering...",await new Promise(d=>t.onbufferedamountlow=d),t.onbufferedamountlow=null,c.textContent="Sending..."}console.info(`[File] Send complete to ${e}: "${s.name}"`),c&&(c.textContent="Sent!"),this.currentSendingFiles.delete(e),this.sendingAcks.delete(e),this.flushQueue(e)}async finishReceive(e){var o,r;const t=this.receivingFiles.get(e);if(!t){console.error(`[File] No receiving state found for peer ${e}`);return}console.info(`[File] Finishing receive from ${e}: "${t.fileName}"`);const n=new Blob(t.buffer),s=await m(await n.arrayBuffer()),i=(o=t.fileItemEl)==null?void 0:o.querySelector(".file-status"),a=(r=t.fileItemEl)==null?void 0:r.querySelector("a");if(s===t.expectedHash){console.info(`[File] ${e} hash match, creating download link`);const c=URL.createObjectURL(n);a&&(a.href=c,a.download=t.fileName,a.style.display="inline-block"),i&&(i.textContent="Received! Click to download.")}else console.error(`[File] ${e} hash mismatch! Expected: ${t.expectedHash}, Got: ${s}`),i&&(i.textContent="Error: Hash Mismatch!"),this.showAlert("File Error",`Hash mismatch for "${t.fileName}" from ${e}. File might be corrupted.`);this.receivingFiles.delete(e)}addPeerToUI(e,t){let n=document.getElementById(`peer-${e}`);n?this.updatePeerStatusUI(e,t):(n=document.createElement("li"),n.id=`peer-${e}`,n.className="peer-item",n.innerHTML=`
        <div>
          <span class="status-indicator ${t}"></span>
          <strong>Peer: ${e}</strong>
          <span class="peer-status">(${t})</span>
        </div>
        <div class="peer-actions">
          <input type="file" id="send-file-to-${e}" class="peer-file-input" style="display:none;" multiple>
          <button class="select-file-btn" data-peer-id="${e}">Send File</button>
        </div>
        <ul class="received-files-list"></ul>
      `,this.peerList.appendChild(n),n.querySelector(".select-file-btn").addEventListener("click",()=>{n.querySelector(`#send-file-to-${e}`).click()}),n.querySelector(`#send-file-to-${e}`).addEventListener("change",a=>{a.target.files.length>0&&this.sendFileToPeer(e,a.target.files[0].name)}))}removePeer(e){var n;console.debug(`[Lifecycle] Removing peer ${e}`),(n=this.peerConnections.get(e))==null||n.close(),this.peerConnections.delete(e),this.dataChannels.delete(e),this.makingOffer.delete(e),this._pendingCandidates.delete(e),this.fileQueues.delete(e),this.currentSendingFiles.delete(e),this.sendingAcks.delete(e),this.receivingFiles.delete(e);const t=document.getElementById(`peer-${e}`);t&&t.remove()}updateConnectionStatus(e){this.connectionStatusSpan.textContent=e,e==="Connected"?this.connectionStatusSpan.style.color="green":e==="Disconnected"||e==="Error"?this.connectionStatusSpan.style.color="red":this.connectionStatusSpan.style.color="orange"}updatePeerStatusUI(e,t){const n=document.getElementById(`peer-${e}`);if(n){const s=n.querySelector(".status-indicator"),i=n.querySelector(".peer-status");s.className=`status-indicator ${t.toLowerCase()}`,i.textContent=`(${t})`}}addSentFileToUI(e,t,n){const s=document.createElement("li");return s.innerHTML=`
      <div>
        <strong>Sending to ${e}: ${t}</strong>
        <br>
        <small>${(n/(1024*1024)).toFixed(2)} MB</small>
        <span class="file-status" style="margin-left: 10px;">Pending...</span>
        <div class="progress-bar-container">
          <div class="progress-bar" style="width: 0%;"></div>
        </div>
      </div>
    `,this.fileList.appendChild(s),s}addReceivedFileToUI(e,t,n){const s=document.getElementById(`peer-${e}`);if(!s)return null;const i=s.querySelector(".received-files-list"),a=document.createElement("li");return a.innerHTML=`
      <div>
        <strong>Receiving: ${t}</strong>
        <br>
        <small>${(n/(1024*1024)).toFixed(2)} MB</small>
        <span class="file-status" style="margin-left: 10px;">Receiving...</span>
        <div class="progress-bar-container">
          <div class="progress-bar" style="width: 0%;"></div>
        </div>
        <div class="file-actions">
            <a href="#" download style="display:none; margin-top: 10px;">Download</a>
        </div>
      </div>
    `,i.appendChild(a),a}close(){var e;console.debug("[Lifecycle] Initiating full close"),(e=this.socket)==null||e.close(),this.peerConnections.forEach(t=>{t.close()}),this.peerConnections.clear(),this.dataChannels.clear(),this.updateConnectionStatus("Disconnected"),this.peerList.innerHTML="",this.fileList.innerHTML="",console.debug("[Lifecycle] All connections closed.")}}window.addEventListener("DOMContentLoaded",()=>{new p});p();
